---
layout: post
title: "Python async programming"
date: 2024-10-09 07:38:00 +0900
categories: IT
author: dh.ihm
---

# Async programming

비동기 프로그래밍의 핵심 개념은 동시에 여러 작업을 수행하는 것이 아닙니다. 

시간이 오래 걸리는 **작업을 기다리는 동안 다른 작업을 수행하는 것**입니다. 

## 주요 용어

### async
비동기 함수를 정의 할 때 사용합니다. 

비동기 함수는 호출되면 실행이 중단되고, 다른 작업이 끝난 후 다시 이어집니다.

```python
async def say_hello():
```

### await
비동기 함수 내에서 사용되는 키워드로, 어떤 작업이 완료될 때까지 기다리겠다는 의미입니다. 

예를 들어, 데이터를 불러오는 동안 기다리지만, 그 동안 다른 작업을 할 수 있다는 것입니다. 

아래와 같이 2초 동안 기다리도록 할 수 있는 것이죠. 
 
```python
import asyncio

async def say_hello():
    print("Hello!")
    await asyncio.sleep(2)  # 2초 동안 기다림
    print("How are you?")

async def main():
    await say_hello()

# 이벤트 루프를 실행하여 main() 함수 실행
asyncio.run(main())
```

### 이벤트 루프(Event Loop)
모든 비동기 작업을 관리하고 스케줄링하는 역할을 합니다. 

여러 작업을 처리하는 데 필요한 순서를 제어하며, 하나의 작업이 끝날 때까지 다른 작업을 실행할 수 있도록 도와줍니다.


## Async programming의 장점

- 빠른 반응성: I/O 작업이 완료될 때까지 기다리지 않고, 다른 작업을 계속할 수 있어 응답 속도가 빨라집니다.
- 효율적인 자원 사용: 여러 작업을 동시에 수행할 수 있기 때문에, 자원을 효율적으로 사용할 수 있습니다.
- 병렬성과는 다름: 비동기 프로그래밍은 병렬로 작업을 수행하는 것처럼 보이지만, 실제로는 **한 번에 하나의 작업을 빠르게 전환하며 처리**합니다.


## Event loop의 작동 방식
위에서 살펴 본 것처럼, 이벤트 루프는 모든 비동기 작업을 관리하고 스케줄링 하는 역할을 하는 비동기 프로그래밍의 핵심 개념 중 하나입니다. 

```python
import asyncio

async def task1():
    print("Task 1 시작")
    await asyncio.sleep(2)  # 2초 동안 기다림
    print("Task 1 완료")

async def task2():
    print("Task 2 시작")
    await asyncio.sleep(1)  # 1초 동안 기다림
    print("Task 2 완료")

async def main():
    await asyncio.gather(task1(), task2())

asyncio.run(main())
```

이 코드가 수행되면 결과는 어떻게 될까요?

```
Task 1 시작
Task 2 시작
```

프로그램을 시작하면, 위와 같이 먼저 출력된 후, 1초 후 아래와 같이 출력됩니다. 

```
Task 2 완료
```

그리고 또 다시 1초 후에 아래와 같이 출력되고 프로그램은 종료 됩니다. 

```
Task 1 완료
```

이러한 동작을 할 수 있도록 해주는 것이 이벤트 루프 입니다. 

이벤트 루프가 어떻게 동작하는지 그림으로 좀 더 자세히 살펴 보면, 다음과 같습니다. 

```
            +-------------------------------+
            |           Task Queue          |
            | ----------------------------  |
            | | Task 1 |    T2    |   T3  | |
            +-------------------------------+
                       | Get Task
                       v
            +-------------------------------+    
            |         Event Loop            |  Event loops는 Task queue에서 task를 순차적으로 꺼내서 실행합니다. 
       ---> |-------------------------------|
       |    |          Run Task             |
       |    +-------------------------------+
       |               |
       |               v
       |    +-------------------------------+
       |    |          Task 1               |
       |    |-------------------------------|
       |    |          Run                  |
       |    +-------------------------------+
       |               |
       |               v
       |    +-------------------------------+
       |    |        Coroutine 1            |  실행된 Task의 coroutine에서는 await가 있는 경우, 
       |    |-------------------------------|  아래와 같이 판단을 하게 됩니다. 
       |    |        1) Run                 |
       |    |        2) await Coroutine2()  |
       |    +-------------------------------+
       |               |
       |               v
       |    +-------------------------------+
       |    | Coroutine2가 기다려야 하는가?      |        기다릴 필요가 없는 동작이면 바로 수행을 합니다.
       |    | Sleep이나 I/O 같은 동작인가?       | -----> +-------------------------------+    
       |    +-------------------------------+        |       Coroutine 2             |
       |         |                                   |-------------------------------|                 
       |        YES                                  |          Run                  |
       |         |                                   +-------------------------------+
       |         v                   
       |    +-------------------------------+       
       -----|   제어권 반환                    |  기다려야 할 경우에는 event loop로 제어권이 반환되고,  
            +-------------------------------+  event loop에서는 task queue에서 새로운 task를 꺼내어 실행합니다.                                                                          
```

여기에서 갑자기 coroutine이 등장하게 되는데, 이 부분은 위에서 설명했었습니다. 

바로 async로 함수를 정의하는 부분입니다. 

함수 정의시에 **async** 키워드를 사용하게 되면, 이 함수는 비동기 함수가 되고, 코루틴이 정의되는 것입니다. 

Thread와 유사하지만 더 가볍기 때문에, 더 많은 수의 코루틴이 실행될 수 있습니다. 

코루틴이 생성되는 방식을 아주 조금 더 상세하게 알아 보면 다음과 같습니다.

코루틴은 **async**, **launch** 같은 코루틴 빌더 함수를 통해서 생성이 되는데, 

코루틴 빌더는 내부적으로 **create_task()**를 이용해서 코루틴을 **Task** object로 감싸게 됩니다. 

그 후 **get_running_loop()** 나 **get_event_loop()** 등을 사용해서 현재 실행 중인 이벤트 루프 객체를 가져오고, 

생성된 task를 이벤트 루프의 내부 큐에 등록하게 되는 것이죠. (**loop.create_task()**)

그 다음 task 실행 과정은 위의 텍스트 다이어그램에서 설명하고 있습니다. 


그럼 다시 이벤트 루프로 돌아가서, 이 이벤트 루프는 누가 실행하고 관리하는 걸까요?

## asyncio module

python에서는 asyncio 모듈이 이 이벤트 루프를 관리합니다. (python 인터프리터가 asynio module을 통해 이벤트 루프를 실행하고요)

위 예제에서 볼 수 있는, **asyncio.run()**을 실행하게 되면, 이벤트 루프가 **생성**되고, 모든 task가 완료되면

이벤트 루프가 **닫힙니다**. 

이벤트 루프는 single thread 기반으로 설계되어, 한 번에 하나 밖에 실행이 안됩니다. 

구현의 단순함과 그럼에도 불구하고 효율성을 추구한 설계입니다. 

Data race나 동기화 문제를 피할 수 있으면서도 고성능을 낼 수 있게 되는 것이죠. 


이상으로 간단하게 python의 async programming 동작에 대해서 이야기 해봤습니다. 

아직 Task, Future, 그리고 asyncio module의 동작에 대해서는 살펴 보지 않았는데, 

다른 페이지에서 이어서 하겠습니다. 😜

